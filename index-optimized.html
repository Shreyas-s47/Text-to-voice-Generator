<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text-to-Voice Generator</title>
    <meta name="description" content="Convert text to speech using browser's built-in speech synthesis">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --error-color: #ff6b6b;
            --border-color: #e1e5e9;
            --text-color: #333;
            --text-light: #555;
            --border-radius: 10px;
            --border-radius-lg: 20px;
            --shadow: 0 20px 40px rgba(0,0,0,0.1);
            --shadow-hover: 0 10px 20px rgba(102, 126, 234, 0.3);
            --transition: all 0.3s ease;
        }
        
        *{margin:0;padding:0;box-sizing:border-box}
        
        body{
            font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
            background:var(--primary-gradient);
            min-height:100vh;
            display:flex;
            align-items:center;
            justify-content:center;
            padding:20px;
            contain:layout style paint
        }
        
        .container{
            background:#fff;
            border-radius:var(--border-radius-lg);
            box-shadow:var(--shadow);
            padding:40px;
            max-width:600px;
            width:100%;
            contain:layout style paint
        }
        
        h1{
            text-align:center;
            color:var(--text-color);
            margin-bottom:30px;
            font-size:2.5em;
            background:var(--primary-gradient);
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
            background-clip:text
        }
        
        .form-group{margin-bottom:25px}
        
        label{
            display:block;
            margin-bottom:8px;
            font-weight:600;
            color:var(--text-light)
        }
        
        textarea{
            width:100%;
            min-height:120px;
            padding:15px;
            border:2px solid var(--border-color);
            border-radius:var(--border-radius);
            font-size:16px;
            font-family:inherit;
            resize:vertical;
            transition:border-color 0.3s ease
        }
        
        textarea:focus{
            outline:none;
            border-color:var(--primary-color);
            box-shadow:0 0 0 3px rgba(102,126,234,0.1)
        }
        
        .controls{
            display:grid;
            grid-template-columns:1fr 1fr;
            gap:20px;
            margin-bottom:25px
        }
        
        select,input[type="range"]{
            width:100%;
            padding:10px;
            border:2px solid var(--border-color);
            border-radius:8px;
            font-size:14px;
            transition:border-color 0.3s ease
        }
        
        select:focus{
            outline:none;
            border-color:var(--primary-color)
        }
        
        .range-group{display:flex;flex-direction:column}
        
        .range-value{
            text-align:center;
            margin-top:5px;
            font-weight:600;
            color:var(--primary-color)
        }
        
        input[type="range"]{
            -webkit-appearance:none;
            appearance:none;
            height:6px;
            background:var(--border-color);
            border-radius:3px;
            padding:0
        }
        
        input[type="range"]::-webkit-slider-thumb{
            -webkit-appearance:none;
            appearance:none;
            width:20px;
            height:20px;
            background:var(--primary-color);
            border-radius:50%;
            cursor:pointer
        }
        
        .buttons{
            display:flex;
            gap:15px;
            justify-content:center
        }
        
        button{
            padding:15px 30px;
            border:none;
            border-radius:var(--border-radius);
            font-size:16px;
            font-weight:600;
            cursor:pointer;
            transition:var(--transition);
            display:flex;
            align-items:center;
            gap:8px;
            will-change:transform
        }
        
        .speak-btn{
            background:var(--primary-gradient);
            color:#fff
        }
        
        .speak-btn:hover:not(:disabled){
            transform:translateY(-2px);
            box-shadow:var(--shadow-hover)
        }
        
        .stop-btn{
            background:var(--error-color);
            color:#fff
        }
        
        .stop-btn:hover{
            background:#ff5252;
            transform:translateY(-2px);
            box-shadow:0 10px 20px rgba(255,107,107,0.3)
        }
        
        .speaking{
            animation:pulse 1.5s infinite
        }
        
        @keyframes pulse{
            0%{transform:scale(1)}
            50%{transform:scale(1.05)}
            100%{transform:scale(1)}
        }
        
        .status{
            text-align:center;
            margin-top:20px;
            padding:10px;
            border-radius:8px;
            font-weight:500
        }
        
        .status.speaking{
            background:#e8f5e8;
            color:#2e7d32
        }
        
        .status.error{
            background:#ffebee;
            color:#c62828
        }
        
        @media (max-width:600px){
            .controls{grid-template-columns:1fr}
            .buttons{flex-direction:column}
        }
        
        @media (prefers-reduced-motion:reduce){
            *{animation-duration:0.01ms !important;animation-iteration-count:1 !important;transition-duration:0.01ms !important}
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ Text-to-Voice</h1>
        
        <div class="form-group">
            <label for="textInput">Enter text to speak:</label>
            <textarea id="textInput" placeholder="Type your text here...">Hello! Welcome to the text-to-voice generator. This tool can speak any text you enter using your browser's built-in speech synthesis.</textarea>
        </div>

        <div class="controls">
            <div class="form-group">
                <label for="voiceSelect">Voice:</label>
                <select id="voiceSelect">
                    <option value="">Loading voices...</option>
                </select>
            </div>

            <div class="form-group">
                <label for="rateRange">Speed:</label>
                <div class="range-group">
                    <input type="range" id="rateRange" min="0.1" max="2" step="0.1" value="1">
                    <div class="range-value" id="rateValue">1.0x</div>
                </div>
            </div>

            <div class="form-group">
                <label for="pitchRange">Pitch:</label>
                <div class="range-group">
                    <input type="range" id="pitchRange" min="0" max="2" step="0.1" value="1">
                    <div class="range-value" id="pitchValue">1.0</div>
                </div>
            </div>

            <div class="form-group">
                <label for="volumeRange">Volume:</label>
                <div class="range-group">
                    <input type="range" id="volumeRange" min="0" max="1" step="0.1" value="1">
                    <div class="range-value" id="volumeValue">100%</div>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button id="speakBtn" class="speak-btn">
                üîä Speak
            </button>
            <button id="stopBtn" class="stop-btn">
                ‚èπÔ∏è Stop
            </button>
        </div>

        <div id="status" class="status" style="display: none;"></div>
    </div>

    <script>
        // Utility functions
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        class TextToVoiceOptimized {
            constructor() {
                // Check for browser support early
                if (!('speechSynthesis' in window)) {
                    this.renderUnsupportedMessage();
                    return;
                }

                this.synth = window.speechSynthesis;
                this.voices = [];
                this.currentUtterance = null;
                this.elements = {}; // Cache for DOM elements
                
                this.init();
            }

            init() {
                this.cacheElements();
                this.bindEvents();
                this.loadVoices();
            }

            cacheElements() {
                // Cache all DOM elements in one go
                const elementIds = [
                    'textInput', 'voiceSelect', 'rateRange', 'pitchRange', 
                    'volumeRange', 'rateValue', 'pitchValue', 'volumeValue', 
                    'speakBtn', 'stopBtn', 'status'
                ];
                
                elementIds.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
            }

            loadVoices() {
                // Use RAF to avoid blocking main thread
                requestAnimationFrame(() => {
                    const voices = this.synth.getVoices();
                    
                    if (voices.length === 0) {
                        // Voices not loaded yet, wait for event
                        this.synth.addEventListener('voiceschanged', () => {
                            this.populateVoices();
                        }, { once: true }); // Use once option for automatic cleanup
                    } else {
                        this.populateVoices();
                    }
                });
            }

            populateVoices() {
                this.voices = this.synth.getVoices();
                const select = this.elements.voiceSelect;
                
                // Use DocumentFragment for efficient DOM manipulation
                const fragment = document.createDocumentFragment();

                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Default Voice';
                fragment.appendChild(defaultOption);

                // Populate with available voices
                this.voices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})${voice.default ? ' - Default' : ''}`;
                    fragment.appendChild(option);
                });

                // Single DOM update
                select.innerHTML = '';
                select.appendChild(fragment);
            }

            bindEvents() {
                // Main action buttons
                this.elements.speakBtn.addEventListener('click', () => this.speak());
                this.elements.stopBtn.addEventListener('click', () => this.stop());

                // Debounced range updates to improve performance
                const updateRateValue = debounce(() => {
                    this.elements.rateValue.textContent = this.elements.rateRange.value + 'x';
                }, 16); // ~60fps

                const updatePitchValue = debounce(() => {
                    this.elements.pitchValue.textContent = this.elements.pitchRange.value;
                }, 16);

                const updateVolumeValue = debounce(() => {
                    this.elements.volumeValue.textContent = Math.round(this.elements.volumeRange.value * 100) + '%';
                }, 16);

                // Use passive listeners where possible for better scroll performance
                this.elements.rateRange.addEventListener('input', updateRateValue, { passive: true });
                this.elements.pitchRange.addEventListener('input', updatePitchValue, { passive: true });
                this.elements.volumeRange.addEventListener('input', updateVolumeValue, { passive: true });

                // Keyboard shortcut with proper cleanup
                this.keydownHandler = (e) => {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.speak();
                    }
                };
                this.elements.textInput.addEventListener('keydown', this.keydownHandler);

                // Visibility change handler for proper cleanup
                this.visibilityHandler = () => {
                    if (document.hidden && this.synth.speaking) {
                        this.stop();
                    }
                };
                document.addEventListener('visibilitychange', this.visibilityHandler);
            }

            speak() {
                const text = this.elements.textInput.value.trim();
                
                if (!text) {
                    this.showStatus('Please enter some text to speak!', false);
                    return;
                }

                // Stop any current speech
                this.stop();

                try {
                    // Create new utterance
                    this.currentUtterance = new SpeechSynthesisUtterance(text);

                    // Set voice
                    const selectedVoiceIndex = this.elements.voiceSelect.value;
                    if (selectedVoiceIndex !== '' && this.voices[selectedVoiceIndex]) {
                        this.currentUtterance.voice = this.voices[selectedVoiceIndex];
                    }

                    // Set parameters
                    this.currentUtterance.rate = parseFloat(this.elements.rateRange.value);
                    this.currentUtterance.pitch = parseFloat(this.elements.pitchRange.value);
                    this.currentUtterance.volume = parseFloat(this.elements.volumeRange.value);

                    // Event listeners with proper error handling
                    this.currentUtterance.onstart = () => {
                        this.setSpeakingState(true);
                    };

                    this.currentUtterance.onend = () => {
                        this.setSpeakingState(false);
                        this.cleanup();
                    };

                    this.currentUtterance.onerror = (event) => {
                        console.error('Speech synthesis error:', event.error);
                        this.setSpeakingState(false);
                        this.showStatus(`Error: ${event.error}`, false);
                        this.cleanup();
                    };

                    // Start speaking
                    this.synth.speak(this.currentUtterance);
                } catch (error) {
                    console.error('Failed to create speech utterance:', error);
                    this.showStatus('Failed to initialize speech', false);
                }
            }

            stop() {
                if (this.synth.speaking) {
                    this.synth.cancel();
                    this.setSpeakingState(false);
                    this.cleanup();
                }
            }

            setSpeakingState(isSpeaking) {
                const btn = this.elements.speakBtn;
                
                if (isSpeaking) {
                    btn.classList.add('speaking');
                    btn.innerHTML = 'üîä Speaking...';
                    btn.disabled = true;
                    this.showStatus('Speaking...', true);
                } else {
                    btn.classList.remove('speaking');
                    btn.innerHTML = 'üîä Speak';
                    btn.disabled = false;
                    this.hideStatus();
                }
            }

            showStatus(message, isPositive = true) {
                const status = this.elements.status;
                status.textContent = message;
                status.className = `status ${isPositive ? 'speaking' : 'error'}`;
                status.style.display = 'block';

                // Auto-hide error messages after 3 seconds
                if (!isPositive) {
                    setTimeout(() => this.hideStatus(), 3000);
                }
            }

            hideStatus() {
                this.elements.status.style.display = 'none';
            }

            cleanup() {
                // Proper cleanup of speech utterance
                if (this.currentUtterance) {
                    this.currentUtterance.onstart = null;
                    this.currentUtterance.onend = null;
                    this.currentUtterance.onerror = null;
                    this.currentUtterance = null;
                }
            }

            destroy() {
                // Cleanup method for proper memory management
                this.stop();
                
                if (this.keydownHandler) {
                    this.elements.textInput.removeEventListener('keydown', this.keydownHandler);
                }
                
                if (this.visibilityHandler) {
                    document.removeEventListener('visibilitychange', this.visibilityHandler);
                }
                
                this.cleanup();
            }

            renderUnsupportedMessage() {
                document.body.innerHTML = `
                    <div class="container">
                        <h1>üö´ Not Supported</h1>
                        <p style="text-align: center; color: #666; font-size: 18px;">
                            Sorry, your browser doesn't support the Web Speech API. 
                            Please try using Chrome, Firefox, Safari, or Edge.
                        </p>
                    </div>
                `;
            }
        }

        // Initialize the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.textToVoiceApp = new TextToVoiceOptimized();
            });
        } else {
            window.textToVoiceApp = new TextToVoiceOptimized();
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.textToVoiceApp && window.textToVoiceApp.destroy) {
                window.textToVoiceApp.destroy();
            }
        });
    </script>
</body>
</html>